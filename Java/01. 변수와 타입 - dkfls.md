# 1. 변수(Variable)

## 1. 변수란?
 - 하나의 값을 저장할 수 있는 메모리 공간

---

## 2. 변수의 선언
 [자료형] [변수명] = 데이터;
 int num = 20;

---

## 3. 변수의 사용
### (1) 변수값 저장
 - 변수에 값을 저장할 때 대입 연산자(=)를 사용한다
 - 변수에 직접 입력된 값을 **리터럴(literal)**이라고 부른다

 #### **리터럴(literal)**
   + 그 `자체`로 값을 나타내는 상수값, 코드 안에서 특정한 값을 직접적으로 표현한 것
   ```
   int a = 10;          // 숫자 10이 리터럴
   char c = 'A';        // 문자 'A'가 리터럴
   String str = "Hi";   // 문자열 "Hi"가 리터럴
   boolean flag = true; // true가 리터럴
   ```

   + 변수를 `초기화` 하거나 `계산`을 수행할 때 사용
   ```
   int x = 10;              // 정수 리터럴 10으로 초기화
   double y = 3.14;         // 실수 리터럴 3.14로 초기화
   boolean isTrue = true;   // 논리 리터럴 true로 초기화
   ```

   + **리터럴의 타입**은 `컴파일러에 의해 자동으로 결정`되나 필요에 따라 `명시적`으로 타입 지정 가능
   ```
   int x = 123;           // 정수 리터럴
   long y = 123L;         // L 접미사를 사용해 long 타입으로 지정
   float z = 3.14f;       // f 접미사를 사용해 float 타입으로 지정
   double w = 3.14;       // 기본적으로 double 타입
   char c = 'A';          // 문자 리터럴
   boolean b = true;      // 논리 리터럴
   ```

   + 리터럴은 코드내에서 사용되는 `상수` 값 그 자체를 의미함, 리터럴은 **"변하지 않는 값"**이라는 의미에서는 `상수`로 간주될 수 있지만 변수에 저장된 값과는 다름
   ```
   final int CONSTANT = 100; // 상수 (변하지 않음)
   int variable = 100;       // 변수 (변경 가능)
   ```
   
   + 특정 타입의 리터럴은 `데이터 타입의 범위`를 초과할 수 없음, 범위를 초과할 시 컴파일 에러 발생 (`리터럴의 유효성`)
   ``` 
   int x = 2147483647;  // 허용 (int의 최대값)
   int y = 2147483648;  // 에러 (int 범위 초과) 
   ```


---
## 데이터 타입에 따라 존재하는 리터럴 종류

### (1) 정수 리터럴

정수 값을 표현하는 리터럴:

| 형식   | 예제     | 설명                          |
|--------|----------|-------------------------------|
| 10진수 | `123`    | 기본 숫자 형태                 |
| 8진수  | `0123`   | 숫자 앞에 `0`을 붙여 8진수로 표현 |
| 16진수 | `0x1A`   | 숫자 앞에 `0x` 또는 `0X`를 붙임  |
| 2진수  | `0b1010` | 숫자 앞에 `0b` 또는 `0B`를 붙임  |



### (2) 실수 리터럴

실수 값을 표현하는 리터럴:

| 형식           | 예제     | 설명                                |
|-----------------|----------|-------------------------------------|
| 고정 소수점     | `3.14`   | 소수점이 있는 일반적인 실수 값        |
| 지수 표현(E표기법) | `1.23e3` | `1.23 × 10³` (결과: `1230`)         |
| `float` 리터럴  | `3.14f`  | `f` 접미사를 붙여 `float` 타입으로 지정 |
| `double` 리터럴 | `3.14`   | 기본적으로 `double` 타입으로 간주   |



### (3) 문자 리터럴

단일 문자를 작은 따옴표(`'`)로 감싸 표현:

| 예제       | 설명                              |
|------------|-----------------------------------|
| `'A'`      | 문자 A                           |
| `'\u0041'` | 유니코드로 표현된 문자 A (16진수) |
| `'\n'`     | 줄바꿈(Newline)                  |



### (4) 문자열 리터럴

참(`true`) 또는 거짓(`false`) 값을 표현:

| 예제            | 설명                       |
|------------------|----------------------------|
| `"Hello"`        | 문자열 "Hello"            |
| `"123"`          | 문자열 "123" (숫자가 아님) |
| `"Hello\nWorld"` | 줄바꿈이 포함된 문자열     |



### (5) 논리 리터럴

| 예제   | 설명  |
|--------|-------|
| `true` | 참    |
| `false`| 거짓  |


---

# 👨‍🚒 메모리의 구조  | `heap` 과 `stack` 

- 메모리 공간을 **주소값의 높고 낮음**의 기준으로 다음과 같다
- static 영역 안에 `코드 영역`과 `데이터 영역`이 존재한다
  1. `코드 영역`   : 실행할 프로그램의 코드가 저장되는 영역, CPU는 여기에 저장된 명령어를 하나씩 가져가서 처리함
  2. `데이터 영역`  : 프로그램의 *전역변수(global variable)*와 *정적변수(static variable)*이 저장되는 영역으로, 프로그램이 시작되는 때에 생성되며, 종료되면 없어진다
  3. `힙 영역`     : 사용자가 직접 관리할 수 있는 영역으로, *사용자에 의해서 동적으로 할당되고 해제*된다. 할당 순서는 *낮은 주소*부터 *높은 주소*로 할당된다 
  4. `스택 영역`   : 
    - 프로그램의 함수 *지역번수(local variable)*와 *매개변수(parameter)*가 저장되는 영역으로, 함수가 호출되면 할당되고 함수가 종료되면 해제된다. 
    - 다른 메모리 영역과 구분되는 특징은 **스택(stack)**구조라는 것이다
    - 나중에 들어간 데이터가 먼저 나오는 구조(**LIFO; Last In, First Out**)로 push 데이터를 저장하고, pop을 통해 **스택(stack)**의 제일 상단에 있는 데이터를 꺼낸다
    - 할당 순서는 높은 주소부터 낮은 주소로 할당된다


---

## 기본 자료형과 참조 자료형

| 구분           | 기본 자료형                     | 참조 자료형               |
|-----------------|-------------------------------|---------------------------------------|
| **데이터 저장** | *값 자체 저장*                    | *메모리 주소 저장* |
| **메모리 위치** | `스택(stack)`에 저장            | `힙(heap)` + `스택(stack)` 저장 |
| **데이터 크기** | 고정크기 (예: `int`는 `4 byte`) | 객체 크기에 따라 다름 |
| **예시**      | `int`, `float` 등             |  `String`, 배열 등 |

- `기본 자료형`은 값 자체를 저장하므로 빠르게 접근할 수 있음
- `참조 자료형`은 객체를 다룰 수 있어 더 복잡한 데이터를 처리할 수 있음

---

## 종류별 메모리 할당  `클래스`, `배열`, `열거`, `인터페이스`

### (1) 클래스 (Class)

```
public class Main {
    public static void main(String[] args) {
        // Stack에 참조 변수 person 저장
        Person person = new Person("홍길동", 25);

        // Heap에 객체 생성
        person.introduce(); // "안녕하세요, 제 이름은 홍길동이고, 나이는 25살입니다." 출력
    }
}

class Person {
    String name; // Heap에 저장되는 필드
    int age;     // Heap에 저장되는 필드

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void introduce() {
        System.out.println("안녕하세요, 제 이름은 " + name + "이고, 나이는 " + age + "살입니다.");
    }
}
```
![메모리-클래스](https://github.com/CHOI-AHRIN/base/blob/master/img/01.%20Memory-class.png)


### (2) 배열 (Array)

```
public class Main {
    public static void main(String[] args) {
        // 참조형 배열 생성
        int[] numbers = {1, 2, 3, 4, 5};

        // 참조형 배열 사용
        System.out.println("첫 번째 원소: " + numbers[0]); // 출력: 첫 번째 원소: 1
        System.out.println("배열 길이: " + numbers.length); // 출력: 배열 길이: 5

        // 배열 요소 변경
        numbers[2] = 10;
        System.out.println("세 번째 원소: " + numbers[2]); // 출력: 세 번째 원소: 10
    }
}

```
![메모리-배열]

### (3) 열거형 (Enum)

### (4) 인터페이스 (Interface)
